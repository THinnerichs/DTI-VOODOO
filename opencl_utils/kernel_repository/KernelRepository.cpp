#include "KernelRepository.h"

const int KernelRepository::SingleLinkage = 0;
char * KernelRepository::kernels[] = {
"//#pragma OPENCL EXTENSION cl_intel_printf : enable\n"
"\n"
"#ifdef SEQS_AS_CHARS\n"
"typedef char type_seq;\n"
"#else\n"
"typedef int type_seq;\n"
"#endif\n"
"\n"
"#define UNKNOWN_SYMBOL 23\n"
"\n"
"// divides a by b and gets ceil of the result\n"
"#define _ceildiv(a,b) (((a) + (b) - 1) / (b))\n"
"\n"
"// perform ceil rounding to the closest multiplicity of b\n"
"#define _ceilround(a,b) (((a) + (b) - 1) / (b) * (b))\n"
"\n"
"typedef struct {\n"
"int x;\n"
"int y;\n"
"} Task;\n"
"\n"
"\n"
"__kernel __attribute__((reqd_work_group_size(THREADS_PER_PAIR * PAIRS_PER_TASK, 1, 1)))\n"
"void calculateLCSs(\n"
"global		const	type_seq*		sequences,\n"
"global		const	int*			lengths,\n"
"global		const	int*			offsets,\n"
"global		const	unsigned int*	bitVectors,\n"
"global		const	Task*			tasks,\n"
"global				int*			lcs,\n"
"local				unsigned int*	localBuffer)\n"
"{\n"
"#define task_id		get_group_id(0)\n"
"#define local_size  get_local_size(0)\n"
"\n"
"int pair_id = get_local_id(0) / THREADS_PER_PAIR;\n"
"int pair_offset = get_local_id(0) % THREADS_PER_PAIR;\n"
"int j = pair_offset;\n"
"int x = tasks[task_id].x;\n"
"int y = tasks[task_id].y + pair_id; // task gives only starting index\n"
"\n"
"int bit_length_x = _ceildiv(lengths[x], 32);\n"
"int bv_offset = (bit_length_x % 2 == 0) ? bit_length_x : bit_length_x + 1 ; // round up to even number\n"
"int length_y = (y < x) ? lengths[y] : 0;\n"
"\n"
"local unsigned int* X = localBuffer + pair_id * bv_offset;\n"
"bitVectors += offsets[x];\n"
"global const type_seq *seq_y = (y < x) ? (sequences + offsets[y]) : 0;\n"
"\n"
"#ifdef LOCAL_BIT_VECTORS\n"
"local unsigned int* bv_x = localBuffer + bv_offset * PAIRS_PER_TASK;\n"
"for (int k = get_local_id(0); k < bv_offset * 24; k += local_size) {\n"
"bv_x[k] = bitVectors[k];\n"
"}\n"
"#else\n"
"global const unsigned int* bv_x = bitVectors;\n"
"#endif\n"
"\n"
"unsigned int V, V2, tB, sB = (unsigned int)0;\n"
"int end_i = max(THREADS_PER_PAIR, bit_length_x);\n"
"\n"
"local int reqIters;\n"
"// int last_pair = min(PAIRS_PER_TASK - 1, (x - 1) - (y - pair_id));\n"
"// if (pair_id == last_pair && j == 0) {\n"
"\n"
"// first pair requires most iterations\n"
"if (get_local_id(0) == 0) {\n"
"reqIters = (length_y / THREADS_PER_PAIR + 1) * end_i + (length_y % THREADS_PER_PAIR);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"int itersCount = reqIters;\n"
"\n"
"// process all pairs\n"
"int i = -j;\n"
"for (int iter = 0; iter < itersCount; ++iter) {\n"
"\n"
"bool legal = (i >= 0 && i < bit_length_x && j < length_y);\n"
"int c = legal ? seq_y[j] : UNKNOWN_SYMBOL;\n"
"\n"
"if (c != UNKNOWN_SYMBOL) {\n"
"V = (j == 0) ? ~(unsigned int)0 : X[i];		// initialisation condition\n"
"}\n"
"\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"if (c != UNKNOWN_SYMBOL) { // unknown symbol or illegal index\n"
"tB = V & bv_x[bv_offset * c + i];\n"
"V2 = V + tB + sB;\n"
"\n"
"//		unsigned int sBprev = sB;\n"
"sB = V2 < V;\n"
"X[i] = V2 | (V - tB);\n"
"\n"
"//		printf(\"thread %d, GPU %d, bitv=%08x, V=%08x, tb=%08x, sBprev=%08x, V2=%08x, sB=%08x, X[%d]=%08x\\n\",\n"
"//			pair_offset, j, bv_x[bv_offset * c + i], V, tB, sBprev, V2, sB, i, X[i]);\n"
"\n"
"}\n"
"\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"if (++i == end_i) {\n"
"j += THREADS_PER_PAIR;\n"
"i = 0;\n"
"sB = (unsigned int)0;\n"
"}\n"
"}\n"
"\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"\n"
"int q = 0;\n"
"for (int i = pair_offset; i < bit_length_x; i += THREADS_PER_PAIR) {\n"
"#if __OPENCL_VERSION__  >= 120\n"
"q += popcount(~X[i]);\n"
"#else\n"
"for(V = ~X[i]; V; V &= V-1) { ++q; }\n"
"#endif\n"
"}\n"
"\n"
"local int res[THREADS_PER_PAIR * PAIRS_PER_TASK];\n"
"res[get_local_id(0)] = q;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"if ((pair_offset == 0) && (y < x)) { // first thread for each pair\n"
"q = 0;\n"
"for(int i = 0; i < THREADS_PER_PAIR; ++i) {\n"
"q += res[get_local_id(0) + i];\n"
"}\n"
"\n"
"int global_pair_id = (x * (x - 1) - tasks[0].x * (tasks[0].x - 1)) / 2 + y;\n"
"lcs[global_pair_id] = q;\n"
"}\n"
"}\n"
"\n"
,
""
};